"""
Markdown to HTML converter with professional styling for agentic search responses.

This module converts markdown content generated by LLMs into beautifully styled HTML,
separating content generation (LLM's job) from presentation (Python's job).

Supports multiple dynamic themes:
- professional: Blue accent, clean corporate look (default)
- minimal: Monochrome, ultra-clean design
- dark: Dark mode with vibrant accents
- vibrant: Colorful, energetic design
- nature: Green/earth tones, organic feel
"""

import re
from typing import Optional, Dict, Any


# ============================================================================
# THEME DEFINITIONS
# ============================================================================

THEMES = {
    "professional": {
        "name": "Professional",
        "description": "Blue accent, clean corporate look",
        "font_family": "system-ui, -apple-system, sans-serif",
        "primary_color": "#3498db",      # Blue
        "text_color": "#2c3e50",         # Dark gray
        "text_light": "#34495e",         # Medium gray
        "heading_color": "#1a1a1a",      # Almost black
        "bg_light": "#f8f9fa",           # Light gray background
        "code_color": "#e74c3c",         # Red for inline code
        "border_color": "#e1e8ed",       # Light border
    },
    "minimal": {
        "name": "Minimal",
        "description": "Monochrome, ultra-clean design",
        "font_family": "system-ui, -apple-system, sans-serif",
        "primary_color": "#000000",      # Black
        "text_color": "#333333",         # Dark gray
        "text_light": "#666666",         # Medium gray
        "heading_color": "#000000",      # Black
        "bg_light": "#f5f5f5",           # Very light gray
        "code_color": "#555555",         # Dark gray for code
        "border_color": "#dddddd",       # Light border
    },
    "dark": {
        "name": "Dark",
        "description": "Dark mode with vibrant accents",
        "font_family": "system-ui, -apple-system, sans-serif",
        "primary_color": "#00d4ff",      # Cyan
        "text_color": "#e4e4e4",         # Light gray
        "text_light": "#b8b8b8",         # Medium gray
        "heading_color": "#ffffff",      # White
        "bg_light": "#2a2a2a",           # Dark gray background
        "code_color": "#ff6b9d",         # Pink for inline code
        "border_color": "#404040",       # Dark border
    },
    "vibrant": {
        "name": "Vibrant",
        "description": "Colorful, energetic design",
        "font_family": "system-ui, -apple-system, sans-serif",
        "primary_color": "#ff6b35",      # Orange
        "text_color": "#2d3436",         # Dark gray
        "text_light": "#636e72",         # Medium gray
        "heading_color": "#2d3436",      # Dark gray
        "bg_light": "#fff5e6",           # Warm light background
        "code_color": "#9b59b6",         # Purple for inline code
        "border_color": "#ffeaa7",       # Light orange border
    },
    "nature": {
        "name": "Nature",
        "description": "Green/earth tones, organic feel",
        "font_family": "system-ui, -apple-system, sans-serif",
        "primary_color": "#27ae60",      # Green
        "text_color": "#2c3e50",         # Dark blue-gray
        "text_light": "#7f8c8d",         # Medium gray
        "heading_color": "#16a085",      # Teal
        "bg_light": "#f0fdf4",           # Very light green
        "code_color": "#d35400",         # Orange for inline code
        "border_color": "#d5f4e6",       # Light green border
    },
}


def get_theme(theme_name: str = "professional") -> Dict[str, str]:
    """
    Get theme configuration by name.

    Args:
        theme_name: Theme name (professional, minimal, dark, vibrant, nature)

    Returns:
        Theme configuration dict
    """
    return THEMES.get(theme_name, THEMES["professional"])


def clean_markdown_content(markdown_content: str) -> str:
    """
    Clean and sanitize markdown content before conversion.
    Removes JSON artifacts, curly braces, and unwanted characters.
    """
    if not markdown_content:
        return ""

    content = markdown_content.strip()

    # Remove common JSON artifacts that leak into responses
    # Remove standalone curly braces (not in code blocks)
    content = re.sub(r'(?<!`)\{(?!`)', '', content)  # Remove { not in code
    content = re.sub(r'(?<!`)\}(?!`)', '', content)  # Remove } not in code

    # Remove double braces that sometimes appear
    content = re.sub(r'\{\{', '', content)
    content = re.sub(r'\}\}', '', content)

    # Remove escaped quotes that shouldn't be there
    content = content.replace('\\"', '"')
    content = content.replace("\\'", "'")

    # Remove escaped backslashes that appear in broken tables
    content = content.replace(' \\', '')
    content = re.sub(r'\\\s*\|', '|', content)  # Fix \| patterns
    content = re.sub(r'\|\s*\\', '|', content)  # Fix |\ patterns

    # Remove excessive newlines (more than 2 consecutive)
    content = re.sub(r'\n{3,}', '\n\n', content)

    # Remove any trailing/leading whitespace from lines
    lines = content.split('\n')
    lines = [line.rstrip() for line in lines]
    content = '\n'.join(lines)

    # Remove weird unicode characters sometimes generated
    content = content.replace('\u200b', '')  # Zero-width space
    content = content.replace('\ufeff', '')  # BOM

    return content.strip()


def convert_markdown_to_html(markdown_content: str, theme: str = "professional") -> str:
    """
    Convert markdown to professionally styled HTML with dynamic theming.

    Supports:
    - Headers (# H1, ## H2, ### H3)
    - Bold (**text**)
    - Italic (*text*)
    - Bullet lists (- item or * item)
    - Numbered lists (1. item)
    - Blockquotes (> text) - converted to highlight boxes
    - Tables (| col1 | col2 |)
    - Code blocks (```code```)
    - Inline code (`code`)
    - Links ([text](url))

    Args:
        markdown_content: The markdown text to convert
        theme: Theme name (professional, minimal, dark, vibrant, nature)

    Returns:
        HTML string with inline CSS styling using selected theme
    """
    t = get_theme(theme)  # Get theme colors

    if not markdown_content or not markdown_content.strip():
        return f"<div style='font-family:{t['font_family']};color:{t['text_color']};'><p>No content available.</p></div>"

    # Clean content first
    html = clean_markdown_content(markdown_content)

    # Convert headers (must be done before other conversions)
    html = re.sub(r'^### (.+)$', f"<h3 style='color:{t['text_color']};font-size:1.1em;font-weight:600;margin:20px 0 10px 0;'>\\1</h3>", html, flags=re.MULTILINE)
    html = re.sub(r'^## (.+)$', f"<h2 style='color:{t['text_color']};font-size:1.2em;font-weight:600;margin:24px 0 12px 0;'>\\1</h2>", html, flags=re.MULTILINE)
    html = re.sub(r'^# (.+)$', f"<h1 style='color:{t['heading_color']};font-size:1.5em;font-weight:600;margin:0 0 20px 0;padding-bottom:12px;border-bottom:3px solid {t['primary_color']};'>\\1</h1>", html, flags=re.MULTILINE)

    # Convert blockquotes to highlight boxes (must be before paragraph processing)
    html = re.sub(
        r'^> (.+)$',
        f"<div style='background:{t['bg_light']};border-left:4px solid {t['primary_color']};padding:16px;margin:20px 0;border-radius:4px;'><p style='margin:0;color:{t['text_color']};font-weight:500;'>\\1</p></div>",
        html,
        flags=re.MULTILINE
    )

    # Convert tables
    html = convert_markdown_tables(html, t)

    # Convert code blocks (```code```)
    html = re.sub(
        r'```([a-z]*)\n(.*?)```',
        f"<pre style='background:{t['bg_light']};padding:12px;border-radius:4px;overflow-x:auto;margin:12px 0;'><code style='font-family:monospace;color:{t['text_color']};'>\\2</code></pre>",
        html,
        flags=re.DOTALL
    )

    # Convert inline code (`code`)
    html = re.sub(
        r'`([^`]+)`',
        f"<code style='background:{t['bg_light']};padding:2px 6px;border-radius:3px;font-family:monospace;color:{t['code_color']};font-size:0.9em;'>\\1</code>",
        html
    )

    # Convert links [text](url)
    html = re.sub(
        r'\[([^\]]+)\]\(([^\)]+)\)',
        f"<a href='\\2' style='color:{t['primary_color']};text-decoration:none;font-weight:500;'>\\1</a>",
        html
    )

    # Convert bold **text**
    html = re.sub(r'\*\*(.+?)\*\*', f"<strong style='color:{t['text_color']};font-weight:600;'>\\1</strong>", html)

    # Convert italic *text* (but not * for lists)
    html = re.sub(r'(?<!\*)\*(?!\*)([^\*]+?)(?<!\*)\*(?!\*)', r"<em style='font-style:italic;'>\1</em>", html)

    # Convert unordered lists (- item or * item)
    html = convert_markdown_lists(html, t)

    # Convert remaining paragraphs (text not already wrapped in tags)
    html = convert_paragraphs(html, t)

    # Wrap in styled container
    styled_html = f"""<div style='font-family:{t['font_family']};line-height:1.6;color:{t['text_color']};max-width:100%;'>
{html}
</div>"""

    return styled_html.strip()


def fix_broken_tables(text: str) -> str:
    """
    Attempt to fix common table formatting issues from LLM output.
    Handles cases where pipes are missing or rows are malformed.
    """
    lines = text.split('\n')
    fixed_lines = []
    i = 0

    while i < len(lines):
        line = lines[i]

        # Check if this looks like a table header without proper pipes
        # Pattern: "Header1    Header2" (whitespace separated)
        if i + 1 < len(lines) and not line.startswith('|') and '    ' in line:
            next_line = lines[i + 1]
            # If next line has pipes or looks like data, this might be a broken table header
            if '|' in next_line or (i + 2 < len(lines) and '|' in lines[i + 2]):
                # Convert whitespace-separated header to pipe-delimited
                headers = [h.strip() for h in line.split('    ') if h.strip()]
                if headers:
                    fixed_lines.append('| ' + ' | '.join(headers) + ' |')
                    fixed_lines.append('|' + '|'.join(['---' for _ in headers]) + '|')
                    i += 1
                    continue

        fixed_lines.append(line)
        i += 1

    return '\n'.join(fixed_lines)


def convert_markdown_tables(text: str, theme: Dict[str, str]) -> str:
    """Convert markdown tables to HTML tables with themed styling. Handles malformed tables."""

    # First, try to fix broken table structures
    text = fix_broken_tables(text)

    # Find all table blocks (more forgiving pattern)
    table_pattern = r'(\|.+\|[\n\r]+\|[-: |]+\|[\n\r]+(?:\|.+\|[\n\r]*)+)'

    def replace_table(match):
        table_md = match.group(1)
        lines = [line.strip() for line in table_md.split('\n') if line.strip() and '|' in line]

        if len(lines) < 2:
            return table_md

        # Parse header
        header_cells = [cell.strip() for cell in lines[0].split('|') if cell.strip()]

        if not header_cells:
            return table_md

        # Skip separator line (lines[1])

        # Parse rows - be more forgiving with cell counts
        body_rows = []
        for line in lines[2:]:
            cells = [cell.strip() for cell in line.split('|') if cell.strip()]
            if cells:
                # Pad or trim cells to match header count
                while len(cells) < len(header_cells):
                    cells.append('')
                cells = cells[:len(header_cells)]
                body_rows.append(cells)

        if not body_rows:
            return table_md

        # Build HTML table with theme colors
        html_parts = [
            f"<table style='width:100%;border-collapse:collapse;margin:20px 0;border:1px solid {theme['border_color']};'>",
            f"<thead><tr style='background:{theme['bg_light']};'>"
        ]

        for cell in header_cells:
            html_parts.append(
                f"<th style='padding:12px;text-align:left;font-weight:600;color:{theme['text_color']};border-bottom:2px solid {theme['primary_color']};'>{cell}</th>"
            )

        html_parts.append("</tr></thead><tbody>")

        for row in body_rows:
            html_parts.append(f"<tr style='border-bottom:1px solid {theme['border_color']};'>")
            for cell in row:
                html_parts.append(
                    f"<td style='padding:12px;color:{theme['text_light']};'>{cell}</td>"
                )
            html_parts.append("</tr>")

        html_parts.append("</tbody></table>")

        return ''.join(html_parts)

    return re.sub(table_pattern, replace_table, text, flags=re.MULTILINE)


def convert_markdown_lists(text: str, theme: Dict[str, str]) -> str:
    """Convert markdown lists (both ordered and unordered) to HTML with themed styling."""

    lines = text.split('\n')
    result = []
    in_ul = False
    in_ol = False

    i = 0
    while i < len(lines):
        line = lines[i]

        # Check for unordered list item (- or *)
        ul_match = re.match(r'^[\-\*] (.+)$', line)
        # Check for ordered list item (1. 2. etc)
        ol_match = re.match(r'^(\d+)\. (.+)$', line)

        if ul_match:
            if not in_ul:
                if in_ol:
                    result.append("</ol>")
                    in_ol = False
                result.append("<ul style='margin:12px 0;padding-left:24px;line-height:1.8;'>")
                in_ul = True
            result.append(f"<li style='margin:8px 0;color:{theme['text_light']};'>{ul_match.group(1)}</li>")

        elif ol_match:
            if not in_ol:
                if in_ul:
                    result.append("</ul>")
                    in_ul = False
                result.append("<ol style='margin:12px 0;padding-left:24px;line-height:1.8;'>")
                in_ol = True
            result.append(f"<li style='margin:8px 0;color:{theme['text_light']};'>{ol_match.group(2)}</li>")

        else:
            # Close any open lists
            if in_ul:
                result.append("</ul>")
                in_ul = False
            if in_ol:
                result.append("</ol>")
                in_ol = False
            result.append(line)

        i += 1

    # Close any remaining open lists
    if in_ul:
        result.append("</ul>")
    if in_ol:
        result.append("</ol>")

    return '\n'.join(result)


def convert_paragraphs(text: str, theme: Dict[str, str]) -> str:
    """Wrap text not already in HTML tags into paragraph tags with themed styling."""

    lines = text.split('\n')
    result = []
    in_paragraph = False
    paragraph_lines = []

    for line in lines:
        stripped = line.strip()

        # Check if line is already HTML (starts with <)
        is_html = stripped.startswith('<')

        # Check if line is empty
        is_empty = not stripped

        if is_html:
            # Close any open paragraph
            if in_paragraph and paragraph_lines:
                para_text = ' '.join(paragraph_lines).strip()
                if para_text:
                    result.append(f"<p style='margin:0 0 16px 0;line-height:1.7;color:{theme['text_light']};'>{para_text}</p>")
                paragraph_lines = []
                in_paragraph = False
            result.append(line)

        elif is_empty:
            # Close any open paragraph
            if in_paragraph and paragraph_lines:
                para_text = ' '.join(paragraph_lines).strip()
                if para_text:
                    result.append(f"<p style='margin:0 0 16px 0;line-height:1.7;color:{theme['text_light']};'>{para_text}</p>")
                paragraph_lines = []
                in_paragraph = False
            result.append(line)

        else:
            # Regular text line - add to paragraph
            in_paragraph = True
            paragraph_lines.append(stripped)

    # Close any remaining paragraph
    if in_paragraph and paragraph_lines:
        para_text = ' '.join(paragraph_lines).strip()
        if para_text:
            result.append(f"<p style='margin:0 0 16px 0;line-height:1.7;color:{theme['text_light']};'>{para_text}</p>")

    return '\n'.join(result)


def convert_structured_to_html(synthesis_response, theme: str = "professional") -> str:
    """
    Convert structured SynthesisResponse directly to HTML - NO markdown parsing!
    This is 10x faster than markdown conversion and produces identical styling.

    Args:
        synthesis_response: SynthesisResponse object with summary, sections, key_insights
        theme: Theme name (professional, minimal, dark, vibrant, nature)

    Returns:
        Beautifully styled HTML with zero markdown overhead
    """
    t = get_theme(theme)

    html_parts = []

    # Summary section (overview)
    if synthesis_response.summary:
        html_parts.append(
            f"<div style='background:{t['bg_light']};border-left:4px solid {t['primary_color']};padding:16px;margin:0 0 24px 0;border-radius:4px;'>"
            f"<p style='margin:0;color:{t['text_color']};font-weight:500;font-size:1.05em;line-height:1.7;'>{synthesis_response.summary}</p>"
            f"</div>"
        )

    # Main content sections
    for section in synthesis_response.sections:
        # Section heading
        html_parts.append(
            f"<h2 style='color:{t['text_color']};font-size:1.2em;font-weight:600;margin:24px 0 12px 0;'>{section.heading}</h2>"
        )

        # Section content (plain text, nicely formatted)
        html_parts.append(
            f"<p style='margin:0 0 16px 0;line-height:1.7;color:{t['text_light']};'>{section.content}</p>"
        )

        # Render table if present (for comparisons/data)
        if section.table:
            table_html = f"<table style='width:100%;border-collapse:collapse;margin:20px 0;border:1px solid {t['border_color']};'>"

            # Table headers
            table_html += f"<thead><tr style='background:{t['bg_light']};'>"
            for header in section.table.headers:
                table_html += f"<th style='padding:12px;text-align:left;font-weight:600;color:{t['text_color']};border-bottom:2px solid {t['primary_color']};'>{header}</th>"
            table_html += "</tr></thead>"

            # Table rows
            table_html += "<tbody>"
            for row in section.table.rows:
                table_html += f"<tr style='border-bottom:1px solid {t['border_color']};'>"
                for cell in row:
                    table_html += f"<td style='padding:12px;color:{t['text_light']};'>{cell}</td>"
                table_html += "</tr>"
            table_html += "</tbody></table>"

            html_parts.append(table_html)

    # Key Insights section (rendered as styled list)
    if synthesis_response.key_insights:
        html_parts.append(
            f"<h2 style='color:{t['text_color']};font-size:1.2em;font-weight:600;margin:24px 0 12px 0;'>Key Insights</h2>"
        )

        html_parts.append(
            f"<ul style='margin:12px 0;padding-left:24px;line-height:1.8;'>"
        )

        for insight in synthesis_response.key_insights:
            insight_text = f"<strong style='color:{t['text_color']};font-weight:600;'>{insight.insight}</strong>"

            if insight.supporting_data:
                insight_text += f" <span style='color:{t['text_light']};'>({insight.supporting_data})</span>"

            html_parts.append(
                f"<li style='margin:8px 0;color:{t['text_light']};'>{insight_text}</li>"
            )

        html_parts.append("</ul>")

    # Wrap in styled container
    styled_html = f"""<div style='font-family:{t['font_family']};line-height:1.6;color:{t['text_color']};max-width:100%;'>
{chr(10).join(html_parts)}
</div>"""

    return styled_html.strip()


def generate_no_results_markdown() -> str:
    """Generate a markdown message for when no results are found."""
    return """# No Results Found

Unfortunately, no information was retrieved from the available tools.

## Possible Reasons

- The query may not match available data
- Tools may not be properly configured
- Network or connectivity issues

> Please try rephrasing your query or check the tool configuration.
"""
